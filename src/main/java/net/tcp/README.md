# TCP

客户端和服务器端传输数据需要建立起一个TCP的连接，而TCP不存在连接的的概念，只存在请求和响应，
请求和响应都是基于数据包的形式。

在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样。

在HTTP/1.0中这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，服务器端响应了之后，这个TCP连接就关闭了；

HTTP/1.1中可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。

## TCP 报文的格式
```cpp
|——————————————————————————————————————————————————————————————————|
|        client ip:port          |      server ip:port             |
|__________________________________________________________________|
|                            sequence num                          |
|——————————————————————————————————————————————————————————————————|
|                            ack num                               |
|——————————————————————————————————————————————————————————————————|
|                            flags                                 |
|——————————————————————————————————————————————————————————————————|
```

1. 序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. 确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
3. 标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
   - URG：紧急指针（urgent pointer）有效。
   - ACK：确认序号有效。
   - PSH：接收方应该尽快将这个报文交给应用层。
   - RST：重置连接。
   - SYN：发起一个新连接。
   - FIN：释放一个连接。

**需要注意的是： 不要将确认序号Ack与标志位中的ACK搞混了。确认方Ack=发起方Seq+1，两端配对。**

## 三次握手

![三次握手.png](三次握手.png)

三次握手的过程：

1. 客户端向服务器发送一个TCP的数据包，数据包中的`flags = SYN，seqNum = x`，这时候客户端的状态为`SYN_SENT`。
   
2. 服务器接收到客户端的发送到TCP数据包，通过flags知道客户端是想新建连接，所以服务器结束Listen状态并转为`SYN_RCVD`，并以客户端的`seqNum + 1`，作为确认号，同时
返回服务器的序号`seqNum = y,flags = SYN,ACK`。
   
3. 客户端收到服务器的确认结果后，返回flags = ACK, 确认序号为服务器的sqlNum + 1 也就是 y + 1。

### 为什么需要第三次握手？

因为网络传输其实是有丢包的风险，也有可能会发生网络中断的情况。而第三次握手就是为了在出现这些情况下，避免服务器端开启了一些无用的连接增加，浪费了服务器的
资源，还防止了已经失效的连接突然又传输数据到服务器产生错误。

比如如果在第二次握手服务器返回了应答数据包，但是这时候数据丢失了，客户端一直没有收到，这时候客户端可能因为超时机制，可以重新再发送创建新连接的请求，如果没有
第三次握手，服务器这时候已经返回了应答数据包，表示服务器已经认为连接成功，所以就一直打开着端口等待客户端发送数据，长期以往，就会导致服务器资源的浪费。

## 四次挥手


> 互联网间的通信，TCP/IP协议基于下一跳机制