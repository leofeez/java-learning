# Garbage Collector 垃圾回收器

## 什么是Garbage
没有任何引用指向一个对象或者多个对象（多个对象之间循环引用）

## 如何定位Garbage
- reference count: 引用计数，即在对象上记录着有多少个引用指向它，无法解决循环引用的问题
- root searching: 根可达算法，根对象包含 线程栈变量，静态变量，常量池，JNI指针
  根对象包含：
  * JVM stack
  * native method stack
  * runtime constant pool
  * static reference in method
  * Class

## 垃圾回收算法
- Mark sweep: 标记清除，容易内存碎片化
- Copying: 拷贝，将内存分为两份，当需要垃圾回收时，先将有效内存数据copy到另外一份，并且连续，然后将第一部门的内存整个回收 ，
  此算法存在内存浪费的情况，但是效率高，适合用于存活对象比较少的情况。
- Mark compact: 标记压缩， 在标记的同时对碎片内存进行压缩，即需要移动对象，这样可以减少碎片并且没有内存浪费，但是效率偏低。

## JVM 分代内存模型（用于分代垃圾回收算法）
这里需要注意的是并不是所有的垃圾回收器都是采用的分代模型，比如Epsilon， ZGC， Shenandoah。
但目前大多数的还是依旧采用的分代木星，所以以下内容都是基于分代模型进行讨论：
```
                                /—— Copying                                          /—— Mark Compact
                               /                                                    /
    |—————————————————————————————————————————————|————————————————————————————————————————————————————————|
    |           8         |     1     |    1      |                                                        |
    |          Eden       | survivor0 | survivor1 |                        tenured                         |
    |                     |           |           |                                                        |
    |—————————————————————————————————————————————|————————————————————————————————————————————————————————|
    
    |——————————————————新生代young—————————————————|——————————————————————————old老年代——————————————————————|
                          1                                                     3
```

1. 新生代 young
2. 老年代 old
3. 1.7的时候还有PermGen 永久代/ 1.8 叫元数据区MetaSpace
    1.7PermGen永久代和1.8中的MetaSpace有什么区别？
    - 永久代和元数据区都是存放Class对象
    - 永久代必须制定大小限制，元数据区可以设置大小，无上限（受限于物理内存大小）
    - 字符串常量1.7存放在永久代，1.8存放在堆中
    - MethodArea逻辑上的概念，1.7 就是永久代，1.8就是MetaSpace

## TLAB(Thread Local Allocation Buffer)
线程本地分配缓存
一个线程专用的内存分配区域，为了加速对象分配
每一个线程，都会产生一个TLAB，该线程独享的工作区域
每一个线程，都会默认使用TLAB区域
TLAB用来避免多线程冲突问题，提高对象分配效率。
TLAB缺省情况下仅占有整个Eden空间的1%，也可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。
    
### 对象内存分配的过程
对于小对象：
1. new 对象
2. 优先尝试在栈上分配，在栈上分配有以下优点：
    - 线程私有小对象
    - 无逃逸，只是在一段代码里使用，出了这段代码即无法找到
    - 支持标量替换
    
3. 如果栈上分配不下，则尝试在线程本地缓存中分配空间
    - 多线程的时候不需要竞争Eden区就可以申请空间，提高效率
    
4. 
    
对于比较大的对象：
4. 如果new出来的对象很大，则直接进入老年代。

### GC 的过程分析
YoungGC大多数对象都会被GC，所以在新生代采用Copying算法去清除。
第一次YGC之后活着的对象都会进入survivor0。
第二次YGC的时候，将存活的对象全部copy到survivor1中，这时候直接清除Eden和survivor0中的内存。
...就这样循环
当survivor中的对象年龄足够大，则进入老年代区域，当survivor中内存不足以存放时则进入老年代。

老年代空间满了之后会触发一次FullGC或者叫MajorGC，这种GC会产生 Stop The World现象。

所以GC调优（Generation）目标： 尽量减少Full GC

## 常见的垃圾回收器

到 JDK13 目前已经产生 10 种垃圾回收器
运用在young新生代的垃圾回收器有：
- Serial
- ParNew
- Parallel Scavenge
  
运用在Old老年代的垃圾回收器有：
- CMS
- Serial Old
- Parallel Old
  
以上的垃圾回收器都是基于分代模型。

穿插运用的垃圾回收器有：
- G1
- ZGC
- Shenandoah
- Epsilon

### Serial 年轻代串行化回收
当触发YGC的时候，会stop the world ，然后利用单个的GC线程去进行垃圾回收。

```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   |             |   ——————————>   |          
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Parallel Scavenge 年轻代并行化回收
当触发YGC的时候，会stop the world ，然后利用多个GC线程并行的去进行垃圾回收。

```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   | ————————>   |   ——————————>   | ————————>        
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Parallel New 年轻代并行化回收
当触发YGC的时候，会stop the world ，然后利用多个GC线程并行的去进行垃圾回收。
与Parallel Scavenge 的区别是该垃圾回收器和CMS配合使用
```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   | ————————>   |   ——————————>   | ————————>        
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Serial Old
运用在老年代，原理同 Serial
### Parallel Old
运用在老年代，原理同 Parallel

### CMS - ConcurrentMarkSweep
老年代，并发的，垃圾回收线程可以和用户程序同时运行，减轻Stop the world（200ms）

1.8 默认的垃圾回收器是 Parallel Scavenge + Parallel Old


#JVM 调优

## 第一步，了解生产环境下的垃圾回收器组合

JVM参数分类：
- 标准：- 开头，所有的Hotspot都支持，如java -version
- 非标准：-X，特定版本HotSpot支持
- 不稳定：-XX开头，下个版本可能会取消

-XX:+PrintCommandLineFlag
-XX:+PrintFlagsFinal
-XX:+PrintFlagsInitial