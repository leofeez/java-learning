# Synchronized

如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，即线程安全问题，这时候需要对线程进行同步，
那么synchronized就是实现线程同步的关键字，可以说在并发控制中是必不可少的部分。

## 特性

- 原子性：被synchronized修饰的方法或者代码块，在多线程的场景下都是需要先获取锁，再执行，最后释放锁，这中间的
过程无法被打断（除了利用Thread#stop() 方法，已废弃！）。

- 可见性：synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，
并且在释放锁之前会将对变量的修改刷新到主存当中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。

- 有序性：synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。

- 可重入性：当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，
这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。

## 介绍

synchronized 取得的锁都是对象锁，而不是把一段代码或者方法当做锁。

synchronized 是可重入锁，在同步方法中调用另外一个同步方法可以直接获取到自己的内部锁，
可重入锁也支持父子间的继承关系，这样就不会产生死锁，因为两次获取的锁都是同一个。

synchronized 是非公平的锁。
程序出现Exception则会释放锁。

写方法加synchronized，但是读方法不加synchronized则容易产生脏读。

synchronized修饰符不支持继承，如果父类定了synchronized，子类重写方法要想实现同步，则也必须加synchronized。

synchronized用在方法上和synchronized(this){整个方法}是同等效果，但是建议锁粒度越小越好，所以推荐使用synchronized代码块。

synchronized(Object): 不能用String常量，Integer, Long, 字符串会存在常量池中
并且锁住的对象不能指向别的实例，所以以对象作为锁的时候必须加final防止指向的地址发生改变。

JDK1.5之前早期的时候，synchronized 是重量级的锁，效率比较低。

## 实现原理



## synchronized 的优化

