# Garbage Collector

## 什么是Garbage
没有任何引用指向一个对象或者多个对象（多个对象之间循环引用）

## 如何定位Garbage

- reference count: 引用计数，即在对象上记录着有多少个引用指向它，无法解决循环引用的问题
- root searching: 根可达算法，根对象包含 线程栈变量，静态变量，常量池，JNI指针
  根对象包含：
  * JVM stack
  * native method stack
  * runtime constant pool
  * static reference in method
  * Class

## 垃圾回收算法
- Mark sweep: 标记清除，容易内存碎片化
- Copying: 拷贝，将内存分为两份，当需要垃圾回收时，先将有效内存数据copy到另外一份，并且连续，然后将第一部门的内存整个回收 ，
  此算法存在内存浪费的情况。
- Mark compact: 标记压缩， 在标记的同时对碎片内存进行压缩，这样可以减少碎片并且没有内存浪费，但是效率偏低

## JVM 分代内存模型（用于分代垃圾回收算法）

```
                                /—— Copying                                          /—— Mark Compact
                               /                                                    /
    |——————————————————————————————————————————————————|————————————————————————————————————————————————————————|
    |           8              |     1     |    1      |                                                        |
    |          Eden            | survivor0 | survivor1 |                        tenured                         |
    |                          |           |           |                                                        |
    |——————————————————————————————————————————————————|————————————————————————————————————————————————————————|
    
    |——————————————————新生代young——————————————————————|——————————————————————————old老年代——————————————————————|
                          1                                                           3
```

1. 新生代 young
2. 老年代 old
3. 1.7的时候还有PermGen 永久代/ 1.8 叫元数据区MetaSpace
    1.7PermGen永久代和1.8中的MetaSpace有什么区别？
    - 永久代和元数据区都是存放Class对象
    - 永久代必须制定大小限制，元数据区可以设置大小，无上限（受限于物理内存大小）
    - 字符串常量1.7存放在永久代，1.8存放在堆中
    - MethodArea逻辑上的概念，1.7 就是永久代，1.8就是MetaSpace

new 出来的对象如果不是非常大的对象都是先在Eden区分配空间，如果new出来的对象很大，则直接进入老年代。
YoungGC大多数对象都会被GC，所以在新生代采用Copying算法去清除，YGC之后活着的对象都会进入survivor0。
再次YGC的时候，将活着的对象全部copy到survivor1中，这时候直接清除Eden和survivor0中的内存。
...就这样循环
当survivor中的对象年龄足够大，则进入老年代区域，活着survivor中装不下则进入老年代。

老年代空间满了之后会触发一次FullGC

GC调优（Generation）目标：
- 尽量减少Full GC，因为Full GC 会产生 Stop The World

## 常见的垃圾回收器

到 JDK13 目前已经产生 10 种垃圾回收器
运用在young新生代的垃圾回收器有：
- Serial
- ParNew
- Parallel Scavenge
  
运用在Old老年代的垃圾回收器有：
- CMS
- Serial Old
- Parallel Old
  
以上的垃圾回收器都是基于分代模型。

穿插运用的垃圾回收器有：
- G1
- ZGC
- Shenandoah
- Epsilon

### Serial 年轻代串行化回收
当触发YGC的时候，会stop the world ，然后利用单个的GC线程去进行垃圾回收。

```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   |             |   ——————————>   |          
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Parallel Scavenge 年轻代并行化回收
当触发YGC的时候，会stop the world ，然后利用多个GC线程并行的去进行垃圾回收。

```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   | ————————>   |   ——————————>   | ————————>        
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Parallel New 年轻代并行化回收
当触发YGC的时候，会stop the world ，然后利用多个GC线程并行的去进行垃圾回收。
与Parallel Scavenge 的区别是该垃圾回收器和CMS配合使用
```
           用户线程         GC线程          用户线程
                      |             |                 |          
        ——————————>   | ————————>   |   ——————————>   | ————————>        
        ——————————>   | ————————>   |   ——————————>   | ————————>
        ——————————>   |             |   ——————————>   |          
                      |             |                 |          
        
```

### Serial Old
运用在老年代，原理同 Serial
### Parallel Old
运用在老年代，原理同 Parallel

### CMS - ConcurrentMarkSweep
老年代，并发的，垃圾回收线程可以和用户程序同时运行，减轻Stop the world（200ms）

1.8 默认的垃圾回收器是 Parallel Scavenge + Parallel Old